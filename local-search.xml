<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>活着</title>
    <link href="/2020/08/07/%E6%B4%BB%E7%9D%80/"/>
    <url>/2020/08/07/%E6%B4%BB%E7%9D%80/</url>
    
    <content type="html"><![CDATA[<p>忍受生命赋予我们的责任，忍受现实给予我们的幸福和苦难，无聊和平庸。<br>你要做的最重要的一件事，就是活着。今天，明天，一万天，三万天，更多天，健康的，热情的，充满求知欲地活着。</p>]]></content>
    
    
    
    <tags>
      
      <tag>LIFE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MESH历险记</title>
    <link href="/2020/07/29/MESH%E5%8E%86%E9%99%A9%E8%AE%B0/"/>
    <url>/2020/07/29/MESH%E5%8E%86%E9%99%A9%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="了解mesh"><a href="#了解mesh" class="headerlink" title="了解mesh"></a>了解mesh</h2><h3 id="三角网格数据结构"><a href="#三角网格数据结构" class="headerlink" title="三角网格数据结构"></a>三角网格数据结构</h3><p>三角网格是多边形网格的一种，多边形网格又被称为“Mesh”，是计算机图形学中用于为各种不规则物体建立模型的一种数据结构。现实世界中的物体表面直观上看都是由曲面构成的；而在计算机世界中，由于只能用离散的结构去模拟现实中连续的事物。所以现实世界中的曲面实际上在计算机里是由无数个小的多边形面片去组成的。这样的小面片的集合就被称作Mesh。</p><h3 id="stl网格文件格式"><a href="#stl网格文件格式" class="headerlink" title="stl网格文件格式"></a>stl网格文件格式</h3><p>文件起始的80个字节是文件头，用于存贮文件名；<br>紧接着用 4 个字节的整数来描述模型的三角面片个数， 后面逐个给出每个三角面片的几何信息。每个三角面片占用固定的50个字节，依次是:<br>3个4字节浮点数(角面片的法矢量)<br>3个4字节浮点数(第1个顶点的坐标)<br>3个4字节浮点数(第2个顶点的坐标)<br>3个4字节浮点数(第3个顶点的坐标)<br>三角面片的最后2个字节用来描述三角面片的属性信息，一般只保留位置，具体数据不用管。<br>一个完整二进制STL文件的大小为三角形面片数乘以 50再加上84个字节。</p><h2 id="读入mesh"><a href="#读入mesh" class="headerlink" title="读入mesh"></a>读入mesh</h2><p>根据81~84字节读出的三角面片个数进行循环，依次读出每个三角面片的法线和三个顶点数据，以及在本次计算中可忽略的面片属性信息，存入faces数组中。<br>整了段代码：</p><pre><code class="bash">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;//文件头，共84字节struct Head{    char partName[80];//零件名称    int  faceNum;//面的数目};//点，三个float类型的，大小为12字节struct Point{    float x;    float y;    float z;};//法线struct Normal{    float i;    float j;    float k;};//三角面，由一个法线，三个点，和一个两字节的保留项，一共50字节struct Face{    Normal normal;    Point  p1;    Point  p2;    Point  p3;    char  info[2];//保留数据，可以不用管};int main(){    Head head;    FILE* fp;    char fileName[128];    printf(&quot;请输入文件名：\n&quot;);    gets_s(fileName);//控制台里输入文件名称    fp = fopen(fileName, &quot;rb&quot;);    if (fp != NULL)    {        fread(head.partName, 80, 1, fp);//获取部件名        fread(&amp;head.faceNum, 4, 1, fp);//获取三角面片的数目    }    Face* faces = (Face*)malloc(head.faceNum * sizeof(Face));//根据三角面片的数目，创建一个Face类型的数组    //循环读取三角面片数据    for (int i = 0; i &lt; head.faceNum; i++)    {        fread(&amp;faces[i].normal, 12, 1, fp);//读取法线数据        fread(&amp;faces[i].p1, 12, 1, fp);//读取顶点1的数据        fread(&amp;faces[i].p2, 12, 1, fp);//读取顶点2的数据        fread(&amp;faces[i].p3, 12, 1, fp);//读取顶点3的数据        fread(&amp;faces[i].info, 2, 1, fp);//读取保留项数据，这一项一般没什么用，这里选择读取是为了移动文件指针    }    fclose(fp);    printf(&quot;STL文件解析如下：\n&quot;);    printf(&quot;三角形数目：&quot;);    printf(&quot;%d\n&quot;, head.faceNum);    printf(&quot;各面的顶点和法线数据如下：\n&quot;);    //在控制台上输出STL文件的数据    for (int i = 0; i &lt; head.faceNum; i++)    {        printf(&quot;面%d\n&quot;, i + 1);        printf(&quot;法线：\n&quot;);        printf(&quot;%f  %f  %f\n&quot;, faces[i].normal.i, faces[i].normal.j, faces[i].normal.k);        printf(&quot;顶点数据：\n&quot;);        printf(&quot;%f  %f  %f\n&quot;, faces[i].p1.x, faces[i].p1.y, faces[i].p1.z);        printf(&quot;%f  %f  %f\n&quot;, faces[i].p2.x, faces[i].p2.y, faces[i].p2.z);        printf(&quot;%f  %f  %f\n&quot;, faces[i].p2.x, faces[i].p2.y, faces[i].p2.z);    }    return 0;}</code></pre><p>读入小零件之后是这个效果</p><p><img src="/img/mesh%E5%8E%86%E9%99%A9%E8%AE%B0-%E8%AF%BB%E5%85%A5%E6%95%88%E6%9E%9C.png" srcset="/img/loading.gif" alt=""></p><p>但其实只要保留读入的部分就行，不必输出。后面的计算也都是在这循环之中进行。</p><h2 id="计算表面积"><a href="#计算表面积" class="headerlink" title="计算表面积"></a>计算表面积</h2><p>2020/7/30 尝试失败<br>2020/8/3 毁灭吧<br>2020/8/7 不过如此</p><p>根据上一节中提取的三角面片，依次计算面积。<br>先计算出三维空间中各边长的长度sa，sb，sc；再利用海伦公式进行面积计算。<br>最后相加算出面积之和即为总表面积sum。</p><pre><code class="bash">for (int i = 0; i &lt; head.faceNum; i++)    {        double sa = sqrt((faces[i].p1.x - faces[i].p2.x) * (faces[i].p1.x - faces[i].p2.x) + (faces[i].p1.y- faces[i].p2.y) * (faces[i].p1.y - faces[i].p2.y) + (faces[i].p1.z- faces[i].p2.z) * (faces[i].p1.z - faces[i].p2.z));        double sb = sqrt((faces[i].p2.x - faces[i].p3.x) * (faces[i].p2.x - faces[i].p3.x) + (faces[i].p2.y - faces[i].p3.y) * (faces[i].p2.y - faces[i].p3.y) + (faces[i].p2.z - faces[i].p3.z) * (faces[i].p2.z - faces[i].p3.z));        double sc = sqrt((faces[i].p3.x - faces[i].p1.x) * (faces[i].p3.x - faces[i].p1.x) + (faces[i].p3.y - faces[i].p1.y) * (faces[i].p3.y - faces[i].p1.y) + (faces[i].p3.z - faces[i].p1.z) * (faces[i].p3.z - faces[i].p1.z));        double sp = (sa + sb + sc) / 2;        sum = sum + sqrt(sp * (sp - sa) * (sp - sb) * (sp - sc));    }</code></pre><h2 id="计算体积"><a href="#计算体积" class="headerlink" title="计算体积"></a>计算体积</h2><p>2020/8/8 👴成功了</p><p>经历了Python和P语言硬算矩阵的纠结之后，我毅然选择了在虚拟机上用Eigen整，Python就是个弟弟！<br>不得不说Linux上KDevelop确实老旧，很有上个世纪九十年代大头计算机的质感。<br><img src="/img/mesh%E5%8E%86%E9%99%A9%E8%AE%B0-%E7%BB%93%E6%9E%9C.png" srcset="/img/loading.gif" alt=""><br>参考了一点<a href="https://wenku.baidu.com/view/276a0b3815791711cc7931b765ce0508763275f7.html" target="_blank" rel="noopener">论文</a>的算法和<a href="https://blog.csdn.net/cxq_1994/article/details/80176702" target="_blank" rel="noopener">博客</a>的代码。<br>将一个与所有三角面片都不相交的面作为投影面，此处取z = -10。三角面片及其在z = -10平面的投影构成了一个凸五面体，计算此五面体体积再求和即为总体积v。<br>凸五面体vs可分割成三个四面体v1，v2，v3；而四面体体积可利用下公式，使用Eigen库来简化矩阵运算。<br>计算出各个面片的投影体积后，将面片法线和投影面法线点乘来判定是上表面还是下表面。若s&gt;0则为上表面，该投影体积为正，若s&lt;0则为下表面，该投影体积为负。</p><pre><code class="bash">for (int i = 0; i &lt; head.faceNum; i++)    {        double x1,x2,x3,y1,y2,y3,z1,z2,z3;        x1=faces[i].p1.x;y1=faces[i].p1.y;z1=faces[i].p1.z;        x2=faces[i].p2.x;y2=faces[i].p2.y;z2=faces[i].p2.z;        x3=faces[i].p3.x;y3=faces[i].p3.y;z3=faces[i].p3.z;        Eigen::Matrix&lt;double,4,4&gt;matrix_44;        matrix_44 &lt;&lt; 1,1,1,1,x1,x2,x3,x2,y1,y2,y3,y2,z1,z2,z3,-10;        double v1=abs(matrix_44.determinant())*(1.0/6.0);        matrix_44 &lt;&lt; 1,1,1,1,x1,x1,x2,x3,y1,y1,y2,y3,z1,-10,-10,z3;        double v2=abs(matrix_44.determinant())*(1.0/6.0);        matrix_44 &lt;&lt; 1,1,1,1,x1,x2,x3,x3,y1,y2,y3,y3,-10,-10,-10,z3;        double v3=abs(matrix_44.determinant())*(1.0/6.0);        double vs=v1+v2+v3;        Eigen::Matrix&lt;double,1,3&gt;f;        f &lt;&lt; faces[i].normal.i, faces[i].normal.j, faces[i].normal.k;        Eigen::Matrix&lt;double,3,1&gt;p;        p &lt;&lt; 0,0,1;        double s = f.dot(p);        if(s&gt;0){          v=v+vs;        }else if(s&lt;0){          v=v-vs;        }    }</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学习了如何用c语言读入stl文件，和mesh的特征，表面积、体积计算方法。并复习了EIgen的使用。<br>以下是总代码：</p><pre><code class="bash">#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;#include &lt;Eigen/Core&gt;#include &lt;Eigen/Dense&gt;using namespace std;using namespace Eigen;struct Head    {    char partName[80];    //文件头    int  faceNum;    //面片个数};struct Point    //顶点{    float x;    float y;    float z;};struct Normal    //法线，k&gt;0上表面，k&lt;0下表面{    float i;    float j;    float k;};struct Face        //单位三角面，一条法线，三个顶点{    Normal normal;        Point  p1;    Point  p2;    Point  p3;    char  info[2];    //保留数据，属性信息};int main(){    Head head;    FILE* fp;    char fileName[128];    fp = fopen(&quot;1.stl&quot;, &quot;rb&quot;);    if (fp != NULL)    {        fread(head.partName, 80, 1, fp);        fread(&amp;head.faceNum, 4, 1, fp);    }    Face* faces = (Face*)malloc(head.faceNum * sizeof(Face));    for (int i = 0; i &lt; head.faceNum; i++)    {        fread(&amp;faces[i].normal, 12, 1, fp);        fread(&amp;faces[i].p1, 12, 1, fp);        fread(&amp;faces[i].p2, 12, 1, fp);        fread(&amp;faces[i].p3, 12, 1, fp);        fread(&amp;faces[i].info, 2, 1, fp);    }    fclose(fp);    double sum = 0;        //表面积    double v=0;        //体积    for (int i = 0; i &lt; head.faceNum; i++)    {        //表面积计算        double sa = sqrt((faces[i].p1.x - faces[i].p2.x) * (faces[i].p1.x - faces[i].p2.x) + (faces[i].p1.y- faces[i].p2.y) * (faces[i].p1.y - faces[i].p2.y) + (faces[i].p1.z- faces[i].p2.z) * (faces[i].p1.z - faces[i].p2.z));        double sb = sqrt((faces[i].p2.x - faces[i].p3.x) * (faces[i].p2.x - faces[i].p3.x) + (faces[i].p2.y - faces[i].p3.y) * (faces[i].p2.y - faces[i].p3.y) + (faces[i].p2.z - faces[i].p3.z) * (faces[i].p2.z - faces[i].p3.z));        double sc = sqrt((faces[i].p3.x - faces[i].p1.x) * (faces[i].p3.x - faces[i].p1.x) + (faces[i].p3.y - faces[i].p1.y) * (faces[i].p3.y - faces[i].p1.y) + (faces[i].p3.z - faces[i].p1.z) * (faces[i].p3.z - faces[i].p1.z));        double sp = (sa + sb + sc) / 2;        sum = sum + sqrt(sp * (sp - sa) * (sp - sb) * (sp - sc));        //体积计算        double x1,x2,x3,y1,y2,y3,z1,z2,z3;        x1=faces[i].p1.x;y1=faces[i].p1.y;z1=faces[i].p1.z;        x2=faces[i].p2.x;y2=faces[i].p2.y;z2=faces[i].p2.z;        x3=faces[i].p3.x;y3=faces[i].p3.y;z3=faces[i].p3.z;        Eigen::Matrix&lt;double,4,4&gt;matrix_44;        matrix_44 &lt;&lt; 1,1,1,1,x1,x2,x3,x2,y1,y2,y3,y2,z1,z2,z3,-10;        double v1=abs(matrix_44.determinant())*(1.0/6.0);        matrix_44 &lt;&lt; 1,1,1,1,x1,x1,x2,x3,y1,y1,y2,y3,z1,-10,-10,z3;        double v2=abs(matrix_44.determinant())*(1.0/6.0);        matrix_44 &lt;&lt; 1,1,1,1,x1,x2,x3,x3,y1,y2,y3,y3,-10,-10,-10,z3;        double v3=abs(matrix_44.determinant())*(1.0/6.0);        double vs=v1+v2+v3;        Eigen::Matrix&lt;double,1,3&gt;f;        f &lt;&lt; faces[i].normal.i, faces[i].normal.j, faces[i].normal.k;        Eigen::Matrix&lt;double,3,1&gt;p;        p &lt;&lt; 0,0,1;        double s = f.dot(p);        if(s&gt;0){          v=v+vs;        }else if(s&lt;0){          v=v-vs;        }    }    printf(&quot;表面积为：%lf\n&quot;, sum);    printf(&quot;体积为: %lf\n&quot;,v);    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>SLAM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《视觉SLAM》3.2 实践：Eigen</title>
    <link href="/2020/04/06/%E3%80%8A%E8%A7%86%E8%A7%89SLAM%E3%80%8B3-2-%E5%AE%9E%E8%B7%B5%EF%BC%9AEigen/"/>
    <url>/2020/04/06/%E3%80%8A%E8%A7%86%E8%A7%89SLAM%E3%80%8B3-2-%E5%AE%9E%E8%B7%B5%EF%BC%9AEigen/</url>
    
    <content type="html"><![CDATA[<h2 id="安装Eigen"><a href="#安装Eigen" class="headerlink" title="安装Eigen"></a>安装Eigen</h2><pre><code class="bash">$ sudo apt-get install libegigen3-dev</code></pre><p>安装完成后输入</p><pre><code class="bash">$ sudo updatedb$ locate eigen3</code></pre><p>查找其头文件的位置，我安装在了<code>/usr/include/eigen3/</code>中<br><img src="/img/Eigen%E5%AE%89%E8%A3%85%E4%BD%8D%E7%BD%AE.png" srcset="/img/loading.gif" alt=""></p><h2 id="开始练习"><a href="#开始练习" class="headerlink" title="开始练习"></a>开始练习</h2><p>编译时出了点小问题</p><h3 id="致-命-错-误-fatal-error"><a href="#致-命-错-误-fatal-error" class="headerlink" title="致 命 错 误 : fatal error"></a>致 命 错 误 : fatal error</h3><p><img src="/img/fatalerror.png" srcset="/img/loading.gif" alt=""><br>因为Eigen安装在<code>/usr/include/eigen3/</code>中，而默认环境变量为<code>/usr/include</code>，因此需添加路径</p><pre><code class="bash">sudo ln -s /usr/include/eigen3/Eigen /usr/include/Eigen</code></pre><p>将<code>/usr/include/eigen3/</code>映射到<code>/usr/include</code>下</p><h3 id="代码及输出"><a href="#代码及输出" class="headerlink" title="代码及输出"></a>代码及输出</h3><pre><code class="bash">#include &lt;iostream&gt;#include&lt;ctime&gt;using namespace std;#include &lt;Eigen/Core&gt;#include &lt;Eigen/Dense&gt;#define MATRIX_SIZE 50int main(){  //Eigen参数：数据类型，行，列  Eigen::Matrix&lt;float,2,3&gt;matrix_23;    //2*3的矩阵  Eigen::Vector3d v_3d;        //Eigen::Matrix&lt;double,3,1&gt;  Eigen::Matrix3d matrix_33 = Eigen::Matrix3d::Zero();        //Eigen::Matrix&lt;double,3,3&gt;,并初始化为零  Eigen::Matrix&lt;double,Eigen::Dynamic,Eigen::Dynamic&gt; matrix_dynamic;        //动态大小  Eigen::MatrixXd matrix_x;  matrix_23 &lt;&lt; 1,2,3,4,5,6;  cout &lt;&lt; matrix_23 &lt;&lt; endl;  // 1 2 3  // 4 5 6  for(int i=0; i&lt;1; i++){    for(int j=0; j&lt;2; j++){      cout &lt;&lt; matrix_23(i,j) &lt;&lt; endl;    }  }  // 1  // 2  v_3d &lt;&lt; 3,2,1;  Eigen::Matrix&lt;double, 2, 1&gt;result = matrix_23.cast&lt;double&gt;()*v_3d;  cout &lt;&lt; result &lt;&lt; endl;  // 10  // 28  //Eigen::Matrix&lt;double,2,3&gt;result_wrong_dimension = matrix_23.cast&lt;double&gt;()*v_3d;  //维度不匹配报错：/usr/include/Eigen/src/Core/Assign.h:492:3: error: ‘YOU_MIXED_MATRICES_OF_DIFFERENT_SIZES’ is not a member of ‘Eigen::internal::static_assertion&lt;false&gt;’  matrix_33 = Eigen::Matrix3d::Random();  cout &lt;&lt; matrix_33 &lt;&lt; endl &lt;&lt; endl;  // 0.680375   0.59688 -0.329554  // -0.211234  0.823295  0.536459  //  0.566198 -0.604897 -0.444451  cout &lt;&lt; matrix_33.transpose() &lt;&lt; endl;    //转置  //  0.680375 -0.211234  0.566198  //   0.59688  0.823295 -0.604897  // -0.329554  0.536459 -0.444451  cout &lt;&lt; matrix_33.sum() &lt;&lt; endl;    //各元素和  //1.61307  cout &lt;&lt; matrix_33.trace() &lt;&lt; endl;     //迹  //1.05922  cout &lt;&lt; 10*matrix_33 &lt;&lt; endl;        //数乘  //  6.80375   5.9688 -3.29554  // -2.11234  8.23295  5.36459  //  5.66198 -6.04897 -4.44451  cout &lt;&lt; matrix_33.inverse() &lt;&lt; endl;        //逆  // -0.198521   2.22739    2.8357  //   1.00605 -0.555135  -1.41603  //  -1.62213   3.59308   3.28973  cout &lt;&lt; matrix_33.determinant() &lt;&lt; endl;    //行列式  //0.208598  Eigen::SelfAdjointEigenSolver&lt;Eigen::Matrix3d&gt;eigen_solver(matrix_33.transpose()*matrix_33);  cout &lt;&lt; &quot;Eigen values = &quot; &lt;&lt; eigen_solver.eigenvalues() &lt;&lt; endl;    //特征值  //Eigen values =   //0.0242899  // 0.992154  // 1.80558  cout &lt;&lt; &quot;Eigen vectors = &quot; &lt;&lt; eigen_solver.eigenvectors() &lt;&lt; endl;    //特征向量  // Eigen vectors =   //-0.549013 -0.735943  0.396198  //  0.253452 -0.598296 -0.760134  // -0.796459  0.316906 -0.514998  Eigen::Matrix&lt;double,MATRIX_SIZE,MATRIX_SIZE&gt;matrix_NN;  matrix_NN = Eigen::MatrixXd::Random(MATRIX_SIZE,MATRIX_SIZE);  Eigen::Matrix&lt; double, MATRIX_SIZE,  1&gt; v_Nd;  v_Nd = Eigen::MatrixXd::Random( MATRIX_SIZE,1 );  clock_t time_stt = clock(); // 计时    // 直接求逆  Eigen::Matrix&lt;double,MATRIX_SIZE,1&gt; x = matrix_NN.inverse()*v_Nd;  cout &lt;&lt;&quot;time use in normal inverse is &quot; &lt;&lt; 1000* (clock() - time_stt)/(double)CLOCKS_PER_SEC &lt;&lt; &quot;ms&quot;&lt;&lt; endl;       // 通常用矩阵分解来求，例如QR分解，速度会快很多  time_stt = clock();  x = matrix_NN.colPivHouseholderQr().solve(v_Nd);   cout &lt;&lt;&quot;time use in Qr decomposition is &quot; &lt;&lt;1000*  (clock() - time_stt)/(double)CLOCKS_PER_SEC &lt;&lt;&quot;ms&quot; &lt;&lt; endl;    //time use in normal inverse is 3.494ms    //time use in Qr decomposition is 9.553ms}</code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre><code>1 2 34 5 61    2    3    4    5    6    10283277 0.680375   0.59688 -0.329554-0.211234  0.823295  0.536459 0.566198 -0.604897 -0.444451 0.680375 -0.211234  0.566198  0.59688  0.823295 -0.604897-0.329554  0.536459 -0.4444511.613071.05922 6.80375   5.9688 -3.29554-2.11234  8.23295  5.36459 5.66198 -6.04897 -4.44451-0.198521   2.22739    2.8357  1.00605 -0.555135  -1.41603 -1.62213   3.59308   3.289730.208598Eigen values = 0.02428990.9921541.80558Eigen vectors = -0.549013 -0.735943  0.396198 0.253452 -0.598296 -0.760134-0.796459  0.316906 -0.514998time use in normal inverse is 3.494mstime use in Qr decomposition is 9.553ms</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>SLAM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日落</title>
    <link href="/2020/04/01/%E6%97%A5%E8%90%BD/"/>
    <url>/2020/04/01/%E6%97%A5%E8%90%BD/</url>
    
    <content type="html"><![CDATA[<p>太阳渐渐黯淡下去<br>感到寂寞而凄凉<br>仿佛人生都被剥夺了</p>]]></content>
    
    
    
    <tags>
      
      <tag>LIFE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《视觉SLAM从入门到放弃》第二讲习题</title>
    <link href="/2020/03/16/%E3%80%8A%E8%A7%86%E8%A7%89SLAM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%E3%80%8B%E7%AC%AC%E4%BA%8C%E8%AE%B2%E4%B9%A0%E9%A2%98/"/>
    <url>/2020/03/16/%E3%80%8A%E8%A7%86%E8%A7%89SLAM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%E3%80%8B%E7%AC%AC%E4%BA%8C%E8%AE%B2%E4%B9%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p><strong>1. 阅读文献<a href="/img/基于单目视觉的同时定位与地图构建方法综述.pdf">[ 1 ]</a>和[ 14 ]，你能看懂文献的内容吗？</strong></p><ol><li>文献[ 1 ]主要专注于对基于单目视觉的 SLAM 方法的分析和讨论, 系统地介绍和分析目前 3 类(基于滤波，关键帧BA,直接跟踪)主流单目 V-SLAM 方法的优缺点, 并对它们的代表性系统进行性能分析和比较。另外, 也介绍和讨论了 V-SLAM 技术的最新研究热点和发展趋势, 并进行总结和展望。</li><li>文献[ 14 ]等找到了就看qwq</li></ol><p><strong>3. g++命令有哪些参数？再怎么填写参数可以更改生成的程序文件名？</strong></p><ol><li><a href="https://blog.csdn.net/huangyimo/article/details/78591990" target="_blank" rel="noopener">g++参数介绍</a></li><li><code>g++ 文件名 -o 执行程序名</code><br>前：<br><img src="/img/ch2_2_1.png" srcset="/img/loading.gif" alt=""><br>后：<br><img src="/img/ch2_2_2.png" srcset="/img/loading.gif" alt=""></li></ol><p><strong>5. 刻意在代码中添加一些语法错误，看看编译会生成什么样的信息。你能看懂 g++ 的错误吗？</strong><br>&emsp;我能！我百度超厉害！</p><p><strong>6. 如果忘了把库链接到可执行程序上，编译会报错吗？什么样的错？</strong><br>&emsp;那必然会<br>&emsp;<code>undefined reference</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>SLAM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>水怪</title>
    <link href="/2020/03/16/%E6%B0%B4%E6%80%AA/"/>
    <url>/2020/03/16/%E6%B0%B4%E6%80%AA/</url>
    
    <content type="html"><![CDATA[<p>我说：“我们好像在池塘的水底，从一个月亮走向另一个月亮。”<br>妖妖忽然大惊小怪地叫起来：“陈辉，你是诗人呢！”</p>]]></content>
    
    
    
    <tags>
      
      <tag>LIFE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟机+博客</title>
    <link href="/2020/03/15/%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/03/15/%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>没想到我居然还是没空<br>先占个坑，有空就写qwq</p><h2 id="hyper-Ubuntu14-4"><a href="#hyper-Ubuntu14-4" class="headerlink" title="hyper+Ubuntu14.4"></a>hyper+Ubuntu14.4</h2><div align=center><a href=https://blog.csdn.net/m0_37835884/article/details/79484242><img src="/img/我已经在线了.jpg" srcset="/img/loading.gif" width = 48%></a></div><h2 id="GitHub-hexo"><a href="#GitHub-hexo" class="headerlink" title="GitHub+hexo"></a>GitHub+hexo</h2><div align=center><a href=https://www.bilibili.com/video/av24897960?from=search&seid=10507961022384070858><img src="/img/我们是兄弟，怎么会鸽你呢.jpg" srcset="/img/loading.gif" width = 50%></a></div><h2 id="一些小问题"><a href="#一些小问题" class="headerlink" title="一些小问题"></a>一些小问题</h2><ol><li><p>关于图片，文档中提供的<code>![](/img/example.jpg)</code>无法更改大小及位置<br>于是用以下方法进行缩小与居中</p><pre><code class="bash">&lt;div align=center&gt;&lt;img src=&quot;/img/example.jpg&quot; width = &quot;200&quot; height = &quot;200&quot;&gt;&lt;/div&gt;</code></pre></li><li><p>经常碰到这种情况 : process faild<br><img src="/img/Processfailed.png" srcset="/img/loading.gif" alt=""><br>经检查还是文章头里的tags没加空格qwq<br><code>tags:SLAM</code><br><code>tags: SLAM</code></p></li><li><p>致 命 错 误 : fatal error<br><img src="/img/fatalerror.png" srcset="/img/loading.gif" alt=""><br>因为Eigen安装在<code>/usr/include/eigen3/</code>中，而默认环境变量为<code>/usr/include</code>，因此需添加路径</p><pre><code class="bash">sudo ln -s /usr/include/eigen3/Eigen /usr/include/Eigen</code></pre><p>将<code>/usr/include/eigen3/</code>映射到<code>/usr/include</code>下</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>SLAM</tag>
      
      <tag>BLOG</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
