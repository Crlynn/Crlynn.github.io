<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>魔王队列</title>
    <link href="/2020/10/29/%E9%AD%94%E7%8E%8B%E9%98%9F%E5%88%97/"/>
    <url>/2020/10/29/%E9%AD%94%E7%8E%8B%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="第二版"><a href="#第二版" class="headerlink" title="第二版"></a>第二版</h2><p>第一版完全没考虑嵌套括号的情况QAQ，老师一写出((ab)(cd))我就知道我败了😭</p><pre><code class="bash">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &quot;SqStack.h&quot;void workA() //特判A{    printf(&quot;sae&quot;);}void workB() //特判B{    printf(&quot;tsaedsae&quot;);}void work_(linkStack* S,LinkQueue* Q) {    char temp;    LinkStack S1;    InitStack(&amp;S1);    while (PoP(S, &amp;temp)) {        if (temp == &#39;)&#39;) {            work_(S,Q);        }        else if (temp != &#39;(&#39;) {            //PoP(&amp;S, &amp;temp);            Push(&amp;S1, temp);        }        else {            char head;            if (PoP(&amp;S1, &amp;head)) {                EnQueue(Q, head);                while (PoP(&amp;S1, &amp;temp)) {                    EnQueue(Q, temp);                    EnQueue(Q, head);                }            }            else {                while (DeQueue(Q, &amp;temp)) {                    Push(&amp;S1, temp);                }                PoP(&amp;S1, &amp;head);                EnQueue(Q, head);                while (PoP(&amp;S1, &amp;temp)) {                    EnQueue(Q, temp);                    EnQueue(Q, head);                }            }            break;        }    }}int main() {    char tmp;    char str[10000];    int len = 0;    LinkStack S;    InitStack(&amp;S);    LinkStack ans;    InitStack(&amp;ans);    printf(&quot;请输入魔王的语言#结束：&quot;);    while ((tmp = getchar()) != &#39;#&#39;) //输入#结束    {        str[len] = tmp;        len++;    }    for (int i = 0; i &lt; len; i++) {        Push(&amp;S, str[i]);    }    while (PoP(&amp;S, &amp;tmp)) {        if (tmp == &#39;)&#39;) {            LinkQueue Q;            InitQueue(&amp;Q);            work_(&amp;S,&amp;Q);            while (DeQueue(&amp;Q, &amp;tmp)) {                Push(&amp;ans, tmp);            }        }        else {            Push(&amp;ans, tmp);        }    }    char sb;    while (PoP(&amp;ans, &amp;sb)) {        printf(&quot;%c&quot;, sb);    }    return 0;}</code></pre><h2 id="第三版"><a href="#第三版" class="headerlink" title="第三版"></a>第三版</h2><p>由于发现第二版不能正确输出(a(ab))，于是我捋了捋题目改了一下顺序。</p><pre><code class="bash">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &quot;SqStack.h&quot;void workA() //特判A{    printf(&quot;sae&quot;);}void workB() //特判B{    printf(&quot;tsaedsae&quot;);}void work_(linkStack* S,LinkQueue* Q) {    char temp;    LinkStack S1;    InitStack(&amp;S1);    while (PoP(S, &amp;temp)) {        if (temp == &#39;)&#39;) {            LinkQueue Qtemp;            InitQueue(&amp;Qtemp);            work_(S,&amp;Qtemp);            char temp_;            LinkStack Stemp;            InitStack(&amp;Stemp);            while (DeQueue(&amp;Qtemp, &amp;temp_)) {                Push(&amp;Stemp, temp_);            }            while (PoP(&amp;Stemp, &amp;temp_)) {                EnQueue(Q, temp_);            }        }        else if (temp != &#39;(&#39;) {            //PoP(&amp;S, &amp;temp);            //Push(&amp;S1, temp);            EnQueue(Q,temp);        }        else {            char head;                while (DeQueue(Q, &amp;temp)) {                    Push(&amp;S1, temp);                }                PoP(&amp;S1, &amp;head);                EnQueue(Q, head);                while (PoP(&amp;S1, &amp;temp)) {                    EnQueue(Q, temp);                    EnQueue(Q, head);                }            break;        }    }}int main() {    char tmp;    char str[10000];    int len = 0;    LinkStack S;    InitStack(&amp;S);    LinkStack ans;    InitStack(&amp;ans);    printf(&quot;请输入魔王的语言#结束：&quot;);    while ((tmp = getchar()) != &#39;#&#39;) //输入#结束    {        str[len] = tmp;        len++;    }    for (int i = 0; i &lt; len; i++) {        Push(&amp;S, str[i]);    }    while (PoP(&amp;S, &amp;tmp)) {        if (tmp == &#39;)&#39;) {            LinkQueue Q;            InitQueue(&amp;Q);            work_(&amp;S,&amp;Q);            while (DeQueue(&amp;Q, &amp;tmp)) {                Push(&amp;ans, tmp);            }        }        else {            Push(&amp;ans, tmp);        }    }    char sb;    while (PoP(&amp;ans, &amp;tmp)) {        if (tmp == &#39;A&#39;) {            printf(&quot;sae&quot;);        }        else if (tmp == &#39;B&#39;) {            printf(&quot;tsaedsae&quot;);        }        else {            printf(&quot;%c&quot;, tmp);        }    }    return 0;}</code></pre><h2 id="第四版"><a href="#第四版" class="headerlink" title="第四版"></a>第四版</h2><p>再去给老师看的时候，(((abc)))，猛陈落泪，输出还挺离谱的。<br>不过一番排查之后发现，其实是括号内输出的时候已经是倒着的序列，我在25行把它正过来了，但实际上我work_()函数内读取的原字符串就是倒着的，因此删除那正过来的一小部分代码就可以了。</p><pre><code class="bash">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &quot;SqStack.h&quot;//void workA() //特判A//{//    printf(&quot;sae&quot;);//}//void workB() //特判B//{//    printf(&quot;tsaedsae&quot;);//}void work_(linkStack* S,LinkQueue* Q) {    char temp;    LinkStack S1;    InitStack(&amp;S1);    while (PoP(S, &amp;temp)) {        if (temp == &#39;)&#39;) {            LinkQueue Qtemp;            InitQueue(&amp;Qtemp);            work_(S,&amp;Qtemp);            char temp_;            LinkStack Stemp;            InitStack(&amp;Stemp);            /*while (DeQueue(&amp;Qtemp, &amp;temp_)) {                Push(&amp;Stemp, temp_);            }            while (PoP(&amp;Stemp, &amp;temp_)) {                EnQueue(Q, temp_);            }*/            while (DeQueue(&amp;Qtemp, &amp;temp_)) {                EnQueue(Q, temp_);            }        }        else if (temp != &#39;(&#39;) {            //PoP(&amp;S, &amp;temp);            //Push(&amp;S1, temp);            EnQueue(Q,temp);        }        else {            char head;                while (DeQueue(Q, &amp;temp)) {                    Push(&amp;S1, temp);                }                PoP(&amp;S1, &amp;head);                EnQueue(Q, head);                while (PoP(&amp;S1, &amp;temp)) {                    EnQueue(Q, temp);                    EnQueue(Q, head);                }            break;        }    }}int main() {    char tmp;    char str[10000];    int len = 0;    LinkStack S;    InitStack(&amp;S);    LinkStack ans;    InitStack(&amp;ans);    printf(&quot;请输入魔王的语言，#结束：&quot;);    while ((tmp = getchar()) != &#39;#&#39;) //输入#结束    {        str[len] = tmp;        len++;    }    for (int i = 0; i &lt; len; i++) {        Push(&amp;S, str[i]);    }    while (PoP(&amp;S, &amp;tmp)) {        if (tmp == &#39;)&#39;) {            LinkQueue Q;            InitQueue(&amp;Q);            work_(&amp;S,&amp;Q);            while (DeQueue(&amp;Q, &amp;tmp)) {                Push(&amp;ans, tmp);            }        }        else {            Push(&amp;ans, tmp);        }    }    char sb;    while (PoP(&amp;ans, &amp;tmp)) {        if (tmp == &#39;A&#39;) {            printf(&quot;sae&quot;);        }        else if (tmp == &#39;B&#39;) {            printf(&quot;tsaedsae&quot;);        }        else {            printf(&quot;%c&quot;, tmp);        }    }    return 0;}</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>大数类运算符重载</title>
    <link href="/2020/10/29/%E5%A4%A7%E6%95%B0%E7%B1%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    <url>/2020/10/29/%E5%A4%A7%E6%95%B0%E7%B1%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<p>不过是老师的作业罢了quq</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><pre><code class="bash">编写并测试一个无限精度的整数类C++内置整形的精度是有限的，例如int类型为32bit，long long类型为64bit。现要求你定义一个类，该类能够表示一个绝对值任意大的整数，对整数能够参与的所有运算进行运算符重载。要求如下：类的实现：1、该类能够表示任意绝对值大小的正负整数和无符号整数2、重载&lt;,&gt;,&lt;=,&gt;=,==,!=等关系运算符，注意保持逻辑的一致性3、重载++,--运算符的前缀和后缀版本4、重载与iostream相关的输入&gt;&gt;和输出&lt;&lt;运算符，自己定义输入和输出格式5、重载+,-,*,/四则运算和%取模运算，除法/得商，取模%得余数6、重载位运算符&amp;,|,^,~7、重载左移&lt;&lt;和右移&gt;&gt;运算符，无符号数实现为逻辑左右移，有符号数为算数左右移8、定义重载的构造函数，能够以各类整形、各类字符串类型、数组或vector初始化对象。9、重载强制类型转换操作符，能够将大整数对象转换为字符串或数组等10、重载赋值运算=和各种复合赋值运算11、重载下标运算符，返回大整数的对应位置的字节，比如a为0xBEEF，则a[0]为0xEF类的测试：依次从大到小输出3个精度为1024bit的素数注意：每一点都有分数，总分100分，允许部分完成。</code></pre><p>一开始是百度的int数组，删删改改还是有限精度，于是又找了一份string的，虽然无限精度了，但缺的算法太多也就懒得改了。<br>最后还是下定决心用vector重做一遍。<br>本来觉着挺难的题目，做了三遍之后：啊，也不过如此嘛 ~</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="bash">#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#define max(a, b)  (((a) &gt; (b)) ? (a) : (b))using namespace std;class BigNum {public:    vector&lt;int&gt;a;    int len;    bool f = 1;    BigNum() { len = 1; f = 1; }    BigNum(const int); //将一个int类型的变量转化成大数    BigNum(const char*); //将一个char数组类型的变量转化为大数    BigNum(const string); //将一个string类型的变量转化为大数    BigNum(const vector&lt;int&gt;); //将一个vector类型的变量转化为大数    BigNum(const BigNum&amp;); //拷贝构造函数    BigNum&amp; operator=(const BigNum&amp;); //重载赋值运算符，大数之间进行赋值运算    friend istream&amp; operator&gt;&gt;(istream&amp;, BigNum&amp;); //重载输入运算符    friend ostream&amp; operator&lt;&lt;(ostream&amp;, BigNum&amp;); //重载输出运算符    void print(); //输出大数    BigNum operator+(const BigNum&amp;)const; //重载加法运算符，两个大数之间的相加运算    BigNum operator-(const BigNum&amp;)const; //重载减法运算符，两个大数之间的相减运算    BigNum operator*(const BigNum&amp;)const; //重载乘法运算符，两个大数之间的相乘运算    BigNum operator/(const int&amp;)const; //重载除法运算符，大数对一个整数进行相除运算    BigNum operator/(const long long&amp;)const; //重载除法运算符，大数对一个长整数进行相除运算    int operator%(const int&amp;)const; //大数对一个int类型的变量进行取模运算    long long operator%(const long long&amp;)const; //大数对一个long long类型的变量进行取模运算    BigNum operator&amp;(const BigNum&amp;)const; //重载位与运算符，大数与大数进行与运算    BigNum operator|(const BigNum&amp;)const; //重载位或运算符，大数与大数进行或运算    BigNum operator^(const BigNum&amp;)const; //重载位异或运算符，大数与大数进行异或运算    BigNum operator~()const; //重载取反运算符，大数自身取反运算    bool operator&gt;(const BigNum&amp; T)const; //大数和另一个大数的大小比较(&gt;)      bool operator&gt;(const int&amp; t)const; //大数和一个int类型的变量的大小比较    bool operator&lt;(const BigNum&amp; T)const; //大数和另一个大数的大小比较(&lt;)    bool operator&gt;=(const BigNum&amp; T)const; //大数和另一个大数的大小比较(&gt;=)    bool operator&lt;=(const BigNum&amp; T)const; //大数和另一个大数的大小比较(&lt;=)    bool operator==(const BigNum&amp; T)const; //大数和另一个大数的大小比较(==)    bool operator!=(const BigNum&amp; T)const; //大数和另一个大数的大小比较(!=)    int&amp; operator[](int x) { return a[x]; } //重载下标运算符，返回大整数的对应位置的字节    BigNum operator&lt;&lt;(const int&amp;)const; //重载左移运算符，大数进行算数左移    BigNum operator&gt;&gt;(const int&amp;)const; //重载右移运算符，大数进行算数右移    BigNum operator+=(const BigNum&amp;); //重载加法复合赋值运算符，两个大数之间的相加运算    BigNum operator-=(const BigNum&amp;); //重载减法复合赋值运算符，两个大数之间的相减运算    BigNum operator*=(const BigNum&amp;); //重载乘法复合赋值运算符，两个大数之间的相乘运算    BigNum operator/=(const int&amp;); //重载除法复合赋值运算符，大数对一个整数进行相除运算    BigNum operator%=(const int&amp;); //重载模运算复合赋值运算符，大数对一个整数进行取模运算    BigNum operator&lt;&lt;=(const int&amp;); //重载左移赋值运算符，大数进行算数左移    BigNum operator&gt;&gt;=(const int&amp;); //重载右移复制运算符，大数进行算数右移    BigNum operator&amp;=(const BigNum&amp;); //重载位与运算符，大数与大数进行与运算    BigNum operator|=(const BigNum&amp;); //重载位或运算符，大数与大数进行或运算    BigNum operator^=(const BigNum&amp;); //重载位异或运算符，大数与大数进行异或运算    BigNum &amp; operator++(); //重载前置自增运算符    BigNum operator++(int); //重载后置自增运算符    BigNum&amp; operator--(); //重载前置自减运算符    BigNum operator--(int); //重载后置自减运算符    operator string(); //重载string强制类型转换    operator char*(); //重载char数组强制类型转换};vector&lt;int&gt; buma(BigNum t1) //将一个大数转换为vector形式的二进制数{    vector&lt;int&gt; x;    while (t1 &gt;= 1) {        x.push_back(t1 % 2);        t1 /= 2;    }    if (t1.f == false) {        for (int i = 0; i &lt; x.size(); i++) {            x[i] = 1 - x[i];        }        x[0]++;        for (int i = 0; i &lt; x.size() - 1; i++) {            if (x[i] &gt; 1) {                x[i] = 0;                x[i + 1]++;            }        }        if (x[x.size()-1] &gt; 1) {            x[x.size()-1] = 0;            x.push_back(1);        }    }    if (t1.f == false) {        x.push_back(1);    }    else {        x.push_back(0);    }    return x;}BigNum::BigNum(const int b) //将一个int类型的变量转化成大数{    int c, d = b;    len = 0;    if (b &lt; 0) {        f = 0;        d = abs(b);    }    while (d &gt; 9) {        c = d - (d / 10) * 10;        d = d / 10;        a.push_back(c);        len++;    }    a.push_back(d);    len++;}BigNum::BigNum(const char* s) //将一个char数组类型的变量转化为大数{    a.clear();    int t, k, L, i;    L = strlen(s);    len = L;    int flag = 0;    if (s[0] == &#39;+&#39;) {        flag = 1;        len--;    }    if (s[0] == &#39;-&#39;) {        flag = 1;        f = 0;        len--;    }    for (i = L - 1; i &gt;= flag; i --)    {        t = 0;        k = i;        t = t * 10 + s[i] - &#39;0&#39;;        a.push_back(t);    }}BigNum::BigNum(const string s) //将一个string类型的变量转化为大数{    a.clear();    int t, k, L, i;    L = s.length();    len = L;    int flag = 0;    if (s[0] == &#39;+&#39;) {        flag = 1;        len--;    }    if (s[0] == &#39;-&#39;) {        flag = 1;        f = 0;        len--;    }    for (i = L - 1; i &gt;= flag; i--)    {        t = 0;        k = i;        t = t * 10 + s[i] - &#39;0&#39;;        a.push_back(t);    }}BigNum::BigNum(const vector&lt;int&gt;v) //将一个vector类型的变量转化为大数{    len = v.size();    for (int i = len - 1; i &gt;= 0; i--) {        a.push_back(v[i]);    }    if (v[0] &lt; 0) {        f = 0;        a[len - 1] = abs(a[len - 1]);    }}BigNum::BigNum(const BigNum&amp; T) :len(T.len) //拷贝构造函数{    int i;    for (i = 0; i &lt; len; i++) {        a.push_back(T.a[i]);    }    f = T.f;}BigNum&amp; BigNum::operator=(const BigNum&amp; n) //重载赋值运算符，大数之间赋值运算{    int i;    len = n.len;    f = n.f;    vector&lt;int&gt;v(len);    for (i = 0; i &lt; len; i++) {        v[i] = n.a[i];    }    a = v;    return *this;}istream&amp; operator&gt;&gt;(istream&amp; in, BigNum&amp; b) {    b.a.clear();    string ch;    int i = -1;    in &gt;&gt; ch;    int flag = 0;    int L = ch.length();    if (ch[0] == &#39;+&#39;) {        flag = 1;    }    if (ch[0] == &#39;-&#39;) {        flag = 1;        b.f = 0;    }    int cnt = 0, sum = 0;    for (i = L - 1; i &gt;= flag;i--) {        sum = 0;        sum += (ch[i] - &#39;0&#39;);        b.a.push_back(sum);        cnt++;    }    b.len = cnt++;    return in;}ostream&amp; operator&lt;&lt;(ostream&amp; out, BigNum&amp; b) //重载输出运算符{    int i;    if (b.f) {        cout &lt;&lt; b.a[b.len - 1];        for (i = b.len - 2; i &gt;= 0; i--) {            printf(&quot;%d&quot;, b.a[i]);        }    }    else {        cout &lt;&lt; &quot;-&quot;;        cout &lt;&lt; b.a[b.len - 1];        for (i = b.len - 2; i &gt;= 0; i--) {            printf(&quot;%d&quot;, b.a[i]);        }    }    return out;}void BigNum::print() //输出大数{    int i;    if (f) {        printf(&quot;%d&quot;, a[len - 1]);        for (i = len - 2; i &gt;= 0; i--)            printf(&quot;%d&quot;, a[i]);    }    else {        cout &lt;&lt; &quot;-&quot;;        printf(&quot;%d&quot;, a[len - 1]);        for (i = len - 2; i &gt;= 0; i--)            printf(&quot;%d&quot;, a[i]);    }    printf(&quot;\n&quot;);}BigNum BigNum::operator+(const BigNum&amp; T)const //两个大数相加{    BigNum t(*this);    BigNum a(*this);    BigNum b(T);    if (a.f == false &amp;&amp; b.f == true) {        a.f = 1;        return b - a;    }    if (a.f == true &amp;&amp; b.f == false) {        b.f = 1;        return a - b;    }    if (a.f == false &amp;&amp; b.f == false) {        t.f = 0;    }    const int big = max(T.len, len);    vector&lt;int&gt;v(big+1);    for (int i = 0; i &lt; big; i++) {        if (i &lt; len)            v[i] += a[i];        if (i &lt; T.len)            v[i] += T.a[i];        if (v[i] &gt; 9)        {            v[i + 1]++;            v[i] -= 10;        }    }    if (v[big] != 0) {        t.len = big + 1;    }    else {        t.len = big;    }    t.a = v;    return t;}BigNum BigNum::operator-(const BigNum&amp; T) const //重载减法运算符，两个大数之间的相减运算{    BigNum t(*this);    BigNum a(*this);    BigNum b(T);    if (a.f == false &amp;&amp; b.f == true) {        b.f = 0;        return a + b;    }    if (a.f == true &amp;&amp; b.f == false) {        b.f = 1;        return a + b;    }    int big = max(T.len, len);    vector&lt;int&gt;x;    vector&lt;int&gt;y;    vector&lt;int&gt;z(big);    bool flag;    if (*this &gt;= T) {        x = t.a;        y = T.a;        flag = 0;    }    else {        x = T.a;        y = t.a;        flag = 1;    }    for (int i = 0; i &lt; big; i++)    {        z[i] += x[i];        if (i &lt; y.size())            z[i] -= y[i];        if (z[i] &lt; 0)        {            z[i] += 10;            z[i + 1]--;        }    }    while (big &gt; 1 &amp;&amp; !z.back())    {        big--;        z.pop_back();    }    if (flag) {        t.f = 0;    }    t.a = z;    t.len = big;    if (a.f == false &amp;&amp; b.f == false) {        t.f = !t.f;    }    return t;}BigNum BigNum::operator*(const BigNum&amp; T)const //两个大数之间的相乘{    BigNum t(*this);    vector&lt;int&gt;v(len+T.len);    for (int i = 0; i &lt; len; i++) {        for (int j = 0; j &lt; T.len; j++) {            v[i + j] += a[i] * T.a[j];        }    }    for (int i = 0; i &lt; len + T.len; i++) {        if (v[i] &gt; 9) {            v[i + 1] += v[i] / 10;            v[i] %= 10;        }    }    while (v.size() &gt; 1 &amp;&amp; !v.back()) {        v.pop_back();    }    t.a = v;    t.len = v.size();    return t;}BigNum BigNum::operator/(const int&amp; b)const //大数对一个整数进行相除运算{    vector&lt;int&gt;v(len);    int i, down = 0;    for (i = len - 1; i &gt;= 0; i--)    {        v[i] = (a[i] + down * 10) / b;        down = a[i] + down * 10 - v[i] * b;    }    BigNum ans;    ans.len = len;    ans.f = f;    while (v[ans.len - 1] == 0 &amp;&amp; ans.len &gt; 1) {        ans.len--;    }    ans.a = v;    return ans;}BigNum BigNum::operator/(const long long&amp; b)const //大数对一个长整数进行相除运算{    vector&lt;int&gt;v(len);    long long i, down = 0;    for (i = len - 1; i &gt;= 0; i--)    {        v[i] = (a[i] + down * 10) / b;        down = a[i] + down * 10 - v[i] * b;    }    BigNum ans;    ans.len = len;    ans.f = f;    while (v[ans.len - 1] == 0 &amp;&amp; ans.len &gt; 1) {        ans.len--;    }    ans.a = v;    return ans;}int BigNum::operator%(const int&amp; b)const //大数对一个 int类型的变量进行取模{    int i, d = 0;    for (i = len - 1; i &gt;= 0; i--)        d = ((d * 10) % b + a[i]) % b;    return d;}long long BigNum::operator%(const long long&amp; b)const //大数对一个long long类型的变量进行取模{    long long i, d = 0;    for (i = len - 1; i &gt;= 0; i--)        d = ((d * 10) % b + a[i]) % b;    return d;}BigNum BigNum::operator&amp;(const BigNum&amp; T) const //重载位与运算符，大数与大数进行与运算{    BigNum t(*this);    vector&lt;int&gt;x;    vector&lt;int&gt;y;    vector&lt;int&gt;z;    BigNum ans = 0;    ans.f = !(!(t.f) &amp; !(T.f));    x = buma(t);    y = buma(T);    if (x.size() &gt;= y.size()) {        int i;        for (i = 0; i &lt; y.size(); i++) {            x[i] = x[i] &amp; y[i];        }        for (; i &lt; x.size(); i++) {            if (T.f) {                y.push_back(0);                x[i] = x[i] &amp; y[i];            }            else {                y.push_back(1);                x[i] = x[i] &amp; y[i];            }        }    }else{        int i;        for (i = 0; i &lt; x.size();i++) {            x[i] = x[i] &amp; y[i];        }        for (; i &lt; y.size();i++) {            if (t.f) {                x.push_back(0);                x[i] = x[i] &amp; y[i];            }            else {                x.push_back(1);                x[i] = x[i] &amp; y[i];            }        }    }    if (ans.f == false) {        if (x[0] == 1) {            x[0] = 0;        }else {            x[0] = 1;            int i = 1;            while (x[i] == 0) {                x[i] = 1;                i++;            }            x[i] = 0;        }        for (int i = 0; i &lt; x.size(); i++) {            x[i] = 1 - x[i];        }    }    BigNum tmp = 1;    if (ans.f == false) {        for (int i = 0; i &lt; x.size(); i++) {            ans -= tmp * x[i];            tmp *= 2;        }    }    else {        for (int i = 0; i &lt; x.size(); i++) {            ans += tmp * x[i];            tmp *= 2;        }    }    ans.len = ans.a.size();    return ans;}BigNum BigNum::operator|(const BigNum&amp; T) const //重载位或运算符，大数与大数进行或运算{    BigNum t(*this);    vector&lt;int&gt;x;    vector&lt;int&gt;y;    vector&lt;int&gt;z;    BigNum ans = 0;    ans.f = !(!(t.f) | !(T.f));    x = buma(t);    y = buma(T);    if (x.size() &gt;= y.size()) {        int i;        for (i = 0; i &lt; y.size(); i++) {            x[i] = x[i] | y[i];        }        for (; i &lt; x.size(); i++) {            if (T.f) {                y.push_back(0);                x[i] = x[i] | y[i];            }            else {                y.push_back(1);                x[i] = x[i] | y[i];            }        }    }    else {        int i;        for (i = 0; i &lt; x.size(); i++) {            x[i] = x[i] | y[i];        }        for (; i &lt; y.size(); i++) {            if (t.f) {                x.push_back(0);                x[i] = x[i] | y[i];            }            else {                x.push_back(1);                x[i] = x[i] | y[i];            }        }    }    if (ans.f == false) {        if (x[0] == 1) {            x[0] = 0;        }        else {            x[0] = 1;            int i = 1;            while (x[i] == 0) {                x[i] = 1;                i++;            }            x[i] = 0;        }        for (int i = 0; i &lt; x.size(); i++) {            x[i] = 1 - x[i];        }    }    BigNum tmp = 1;    if (ans.f == false) {        for (int i = 0; i &lt; x.size(); i++) {            ans -= tmp * x[i];            tmp *= 2;        }    }    else {        for (int i = 0; i &lt; x.size(); i++) {            ans += tmp * x[i];            tmp *= 2;        }    }    ans.len = ans.a.size();    return ans;}BigNum BigNum::operator^(const BigNum&amp; T) const //重载位异或运算符，大数与大数进行异或运算{    BigNum t(*this);    vector&lt;int&gt;x;    vector&lt;int&gt;y;    vector&lt;int&gt;z;    BigNum ans = 0;    ans.f = !(!(t.f) ^ !(T.f));    x = buma(t);    y = buma(T);    if (x.size() &gt;= y.size()) {        int i;        for (i = 0; i &lt; y.size(); i++) {            x[i] = x[i] ^ y[i];        }        for (; i &lt; x.size(); i++) {            if (T.f) {                y.push_back(0);                x[i] = x[i] ^ y[i];            }            else {                y.push_back(1);                x[i] = x[i] ^ y[i];            }        }    }    else {        int i;        for (i = 0; i &lt; x.size(); i++) {            x[i] = x[i] ^ y[i];        }        for (; i &lt; y.size(); i++) {            if (t.f) {                x.push_back(0);                x[i] = x[i] ^ y[i];            }            else {                x.push_back(1);                x[i] = x[i] ^ y[i];            }        }    }    if (ans.f == false) {        if (x[0] == 1) {            x[0] = 0;        }        else {            x[0] = 1;            int i = 1;            while (x[i] == 0) {                x[i] = 1;                i++;            }            x[i] = 0;        }        for (int i = 0; i &lt; x.size(); i++) {            x[i] = 1 - x[i];        }    }    BigNum tmp = 1;    if (ans.f == false) {        for (int i = 0; i &lt; x.size(); i++) {            ans -= tmp * x[i];            tmp *= 2;        }    }    else {        for (int i = 0; i &lt; x.size(); i++) {            ans += tmp * x[i];            tmp *= 2;        }    }    ans.len = ans.a.size();    return ans;}BigNum BigNum::operator~() const //重载取反运算符，大数自身取反运算{    vector&lt;int&gt; x = buma(*this);    BigNum ans=0;    ans.f = !f;    for (int i = 0; i &lt; x.size();i++) {        x[i] = 1 - x[i];    }    if (ans.f == false) {        if (x[0] == 1) {            x[0] = 0;        }        else {            x[0] = 1;            int i = 1;            while (x[i] == 0) {                x[i] = 1;                i++;            }            x[i] = 0;        }        for (int i = 0; i &lt; x.size(); i++) {            x[i] = 1 - x[i];        }    }    BigNum tmp = 1;    if (ans.f == false) {        for (int i = 0; i &lt; x.size(); i++) {            ans -= tmp * x[i];            tmp *= 2;        }    }    else {        for (int i = 0; i &lt; x.size(); i++) {            ans += tmp * x[i];            tmp *= 2;        }    }    ans.len = ans.a.size();    return ans;}bool BigNum::operator&gt;(const BigNum&amp; T)const //大数和另一个大数的大小比较(&gt;){    int ln;    if (len &gt; T.len)return true;    else if (len == T.len)    {        ln = len - 1;        while (ln &gt;= 0 &amp;&amp; a[ln] == T.a[ln])            ln--;        if (ln &gt;= 0 &amp;&amp; a[ln] &gt; T.a[ln])            return true;        else            return false;    }    else        return false;}bool BigNum::operator&gt;(const int&amp; t)const //大数和一个int类型的变量的大小比较{    BigNum b(t);    return *this &gt; b;}bool BigNum::operator&lt;(const BigNum&amp; T)const //大数和另一个大数的大小比较(&lt;){    int ln;    if (len &lt; T.len)return true;    else if (len == T.len)    {        ln = len - 1;        while (ln &gt;= 0 &amp;&amp; a[ln] == T.a[ln])            ln--;        if (ln &gt;= 0 &amp;&amp; a[ln] &lt; T.a[ln])            return true;        else            return false;    }    else        return false;}bool BigNum::operator&gt;=(const BigNum&amp; T)const //大数和另一个大数的大小比较(&gt;=){    return !(*this &lt; T);}bool BigNum::operator&lt;=(const BigNum&amp; T)const //大数和另一个大数的大小比较(&lt;){    return !(*this &gt; T);}bool BigNum::operator==(const BigNum&amp; T)const //大数和另一个大数的大小比较(==){    int ln;    if (len != T.len)return false;    else if (len == T.len)    {        ln = len - 1;        for (int i = ln; i &gt;= 0; i--) {            if (a[i] != T.a[i]) {                return false;            }        }    }    else        return true;}bool BigNum::operator!=(const BigNum&amp; T)const //大数和另一个大数的大小比较(!=){    return !(*this == T);}BigNum BigNum::operator&lt;&lt;(const int&amp; t)const //重载左移运算符，大数进行算数左移{    BigNum T(*this);    for (int i = t; i &gt; 0; i--) {        T *=2;    }    return T;}BigNum BigNum::operator&gt;&gt;(const int&amp; t)const //重载右移运算符，大数进行算数右移{    BigNum T(*this);    for (int i = t; i &gt; 0; i--) {        T = T / 2;    }    return T;}BigNum BigNum::operator+=(const BigNum&amp; T) //重载加法复合赋值运算符，两个大数之间的相加运算{    return *this = *this + T;}BigNum BigNum::operator-=(const BigNum&amp; T) //重载减法复合赋值运算符，两个大数之间的相减运算{    return *this = *this - T;}BigNum BigNum::operator*=(const BigNum&amp; T) //重载乘法复合赋值运算符，两个大数之间的相乘运算{    return *this = *this * T;}BigNum BigNum::operator/=(const int&amp; T) //重载除法复合赋值运算符，大数对一个整数进行相除运算{    return *this = *this / T;}BigNum BigNum::operator%=(const int&amp; T) //重载模运算复合赋值运算符，大数对一个整数进行取模运算{    return *this = *this % T;}BigNum BigNum::operator&lt;&lt;=(const int&amp; T) //重载左移赋值运算符，大数进行算术左移{    return *this = *this &lt;&lt; T;}BigNum BigNum::operator&gt;&gt;=(const int&amp; T) //重载右移赋值运算符，大数进行算术右移{    return *this = *this &gt;&gt; T;}BigNum BigNum::operator&amp;=(const BigNum&amp; T) //重载位与运算符，大数与大数进行与运算{    return *this = *this &amp; T;}BigNum BigNum::operator|=(const BigNum&amp; T) //重载位或运算符，大数与大数进行或运算{    return *this = *this | T;}BigNum BigNum::operator^=(const BigNum&amp; T) //重载位异或运算符，大数与大数进行异或运算{    return *this = *this ^ T;}BigNum&amp; BigNum::operator++() //重载前置自增运算符{    *this += 1;    return *this;}BigNum BigNum::operator++(int) //重载后置自增运算符{    BigNum ans = *this;    ++(*this);    return ans;}BigNum&amp; BigNum::operator--() //重载前置自减运算符{    *this -=1;    return *this;}BigNum BigNum::operator--(int) //重载后置自减运算符{    BigNum ans = *this;    --(*this);    return ans;}BigNum::operator string() //重载string强制类型转换{    string s = &quot;&quot;;    for (int i = len - 1; i &gt;= 0; i--) {        char tmp = (char)a[i]+&#39;0&#39;;        s = s + tmp;    }    return s;}char ss[500];BigNum::operator char*() //重载char数组强制类型转换{    int k = 0;    if (f == false) {        ss[k] = &#39;-&#39;;        k++;    }    for (int i = len - 1; i &gt;= 0; i--) {        char tmp = (char)a[i] + &#39;0&#39;;        ss[k] = { tmp };        k++;    }    return ss;}int main() {    BigNum A = 5;    int flag = 0;    for (int i = 2; A / 2 &gt; i; i++) {        if (A % i == 0) {            flag = 1;            break;        }    }    if (flag) {        cout &lt;&lt; A &lt;&lt; &quot;不是素数&quot; &lt;&lt; endl;    }    else {        cout &lt;&lt; A &lt;&lt; &quot;是素数&quot; &lt;&lt; endl;    }    BigNum B = 524287;    flag = 0;    BigNum k = B / 2;    for (long long i = 2; k &gt; i; i++) {        if (B % i == 0) {            flag = 1;            break;        }    }    if (flag) {        cout &lt;&lt; B &lt;&lt; &quot;不是素数&quot; &lt;&lt; endl;    }    else {        cout &lt;&lt; B &lt;&lt; &quot;是素数&quot; &lt;&lt; endl;    }    BigNum MS_15 = 1;    //第十五位梅森素数，2^1279-1    MS_15 &lt;&lt;= 1279;    MS_15 -= 1;    cout &lt;&lt; &quot;第十五个梅森素数（386位）：&quot; &lt;&lt; MS_15 &lt;&lt; endl;    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MESH历险记</title>
    <link href="/2020/08/09/MESH%E5%8E%86%E9%99%A9%E8%AE%B0/"/>
    <url>/2020/08/09/MESH%E5%8E%86%E9%99%A9%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="了解mesh"><a href="#了解mesh" class="headerlink" title="了解mesh"></a>了解mesh</h2><h3 id="三角网格数据结构"><a href="#三角网格数据结构" class="headerlink" title="三角网格数据结构"></a>三角网格数据结构</h3><p>三角网格是多边形网格的一种，多边形网格又被称为“Mesh”，是计算机图形学中用于为各种不规则物体建立模型的一种数据结构。现实世界中的物体表面直观上看都是由曲面构成的；而在计算机世界中，由于只能用离散的结构去模拟现实中连续的事物。所以现实世界中的曲面实际上在计算机里是由无数个小的多边形面片去组成的。这样的小面片的集合就被称作Mesh。</p><h3 id="stl网格文件格式"><a href="#stl网格文件格式" class="headerlink" title="stl网格文件格式"></a>stl网格文件格式</h3><p>文件起始的80个字节是文件头，用于存贮文件名；<br>紧接着用 4 个字节的整数来描述模型的三角面片个数， 后面逐个给出每个三角面片的几何信息。每个三角面片占用固定的50个字节，依次是:<br>3个4字节浮点数(角面片的法矢量)<br>3个4字节浮点数(第1个顶点的坐标)<br>3个4字节浮点数(第2个顶点的坐标)<br>3个4字节浮点数(第3个顶点的坐标)<br>三角面片的最后2个字节用来描述三角面片的属性信息，一般只保留位置，具体数据不用管。<br>一个完整二进制STL文件的大小为三角形面片数乘以 50再加上84个字节。</p><h2 id="读入mesh"><a href="#读入mesh" class="headerlink" title="读入mesh"></a>读入mesh</h2><p>根据81~84字节读出的三角面片个数进行循环，依次读出每个三角面片的法线和三个顶点数据，以及在本次计算中可忽略的面片属性信息，存入faces数组中。<br>整了段代码：</p><pre><code class="bash">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;//文件头，共84字节struct Head{    char partName[80];//零件名称    int  faceNum;//面的数目};//点，三个float类型的，大小为12字节struct Point{    float x;    float y;    float z;};//法线struct Normal{    float i;    float j;    float k;};//三角面，由一个法线，三个点，和一个两字节的保留项，一共50字节struct Face{    Normal normal;    Point  p1;    Point  p2;    Point  p3;    char  info[2];//保留数据，可以不用管};int main(){    Head head;    FILE* fp;    char fileName[128];    printf(&quot;请输入文件名：\n&quot;);    gets_s(fileName);//控制台里输入文件名称    fp = fopen(fileName, &quot;rb&quot;);    if (fp != NULL)    {        fread(head.partName, 80, 1, fp);//获取部件名        fread(&amp;head.faceNum, 4, 1, fp);//获取三角面片的数目    }    Face* faces = (Face*)malloc(head.faceNum * sizeof(Face));//根据三角面片的数目，创建一个Face类型的数组    //循环读取三角面片数据    for (int i = 0; i &lt; head.faceNum; i++)    {        fread(&amp;faces[i].normal, 12, 1, fp);//读取法线数据        fread(&amp;faces[i].p1, 12, 1, fp);//读取顶点1的数据        fread(&amp;faces[i].p2, 12, 1, fp);//读取顶点2的数据        fread(&amp;faces[i].p3, 12, 1, fp);//读取顶点3的数据        fread(&amp;faces[i].info, 2, 1, fp);//读取保留项数据，这一项一般没什么用，这里选择读取是为了移动文件指针    }    fclose(fp);    printf(&quot;STL文件解析如下：\n&quot;);    printf(&quot;三角形数目：&quot;);    printf(&quot;%d\n&quot;, head.faceNum);    printf(&quot;各面的顶点和法线数据如下：\n&quot;);    //在控制台上输出STL文件的数据    for (int i = 0; i &lt; head.faceNum; i++)    {        printf(&quot;面%d\n&quot;, i + 1);        printf(&quot;法线：\n&quot;);        printf(&quot;%f  %f  %f\n&quot;, faces[i].normal.i, faces[i].normal.j, faces[i].normal.k);        printf(&quot;顶点数据：\n&quot;);        printf(&quot;%f  %f  %f\n&quot;, faces[i].p1.x, faces[i].p1.y, faces[i].p1.z);        printf(&quot;%f  %f  %f\n&quot;, faces[i].p2.x, faces[i].p2.y, faces[i].p2.z);        printf(&quot;%f  %f  %f\n&quot;, faces[i].p2.x, faces[i].p2.y, faces[i].p2.z);    }    return 0;}</code></pre><p>读入小零件之后是这个效果</p><p><img src="/img/mesh%E5%8E%86%E9%99%A9%E8%AE%B0-%E8%AF%BB%E5%85%A5%E6%95%88%E6%9E%9C.png" srcset="/img/loading.gif" alt=""></p><p>但其实只要保留读入的部分就行，不必输出。后面的计算也都是在这循环之中进行。</p><h2 id="计算表面积"><a href="#计算表面积" class="headerlink" title="计算表面积"></a>计算表面积</h2><p>2020/7/30 尝试失败<br>2020/8/3 毁灭吧<br>2020/8/7 不过如此</p><p>根据上一节中提取的三角面片，依次计算面积。<br>先计算出三维空间中各边长的长度sa，sb，sc；再利用海伦公式进行面积计算。<br>最后相加算出面积之和即为总表面积sum。</p><pre><code class="bash">for (int i = 0; i &lt; head.faceNum; i++)    {        double sa = sqrt((faces[i].p1.x - faces[i].p2.x) * (faces[i].p1.x - faces[i].p2.x) + (faces[i].p1.y- faces[i].p2.y) * (faces[i].p1.y - faces[i].p2.y) + (faces[i].p1.z- faces[i].p2.z) * (faces[i].p1.z - faces[i].p2.z));        double sb = sqrt((faces[i].p2.x - faces[i].p3.x) * (faces[i].p2.x - faces[i].p3.x) + (faces[i].p2.y - faces[i].p3.y) * (faces[i].p2.y - faces[i].p3.y) + (faces[i].p2.z - faces[i].p3.z) * (faces[i].p2.z - faces[i].p3.z));        double sc = sqrt((faces[i].p3.x - faces[i].p1.x) * (faces[i].p3.x - faces[i].p1.x) + (faces[i].p3.y - faces[i].p1.y) * (faces[i].p3.y - faces[i].p1.y) + (faces[i].p3.z - faces[i].p1.z) * (faces[i].p3.z - faces[i].p1.z));        double sp = (sa + sb + sc) / 2;        sum = sum + sqrt(sp * (sp - sa) * (sp - sb) * (sp - sc));    }</code></pre><h2 id="计算体积"><a href="#计算体积" class="headerlink" title="计算体积"></a>计算体积</h2><p>2020/8/8 👴成功了</p><p>经历了Python和P语言硬算矩阵的纠结之后，我毅然选择了在虚拟机上用Eigen整，Python就是个弟弟！<br>不得不说Linux上KDevelop确实老旧，很有上个世纪九十年代大头计算机的质感。<br><img src="/img/mesh%E5%8E%86%E9%99%A9%E8%AE%B0-%E7%BB%93%E6%9E%9C.png" srcset="/img/loading.gif" alt=""><br>参考了一点<a href="https://wenku.baidu.com/view/276a0b3815791711cc7931b765ce0508763275f7.html" target="_blank" rel="noopener">论文</a>的算法和<a href="https://blog.csdn.net/cxq_1994/article/details/80176702" target="_blank" rel="noopener">博客</a>的代码。<br>将一个与所有三角面片都不相交的面作为投影面，此处取z = -10。三角面片及其在z = -10平面的投影构成了一个凸五面体，计算此五面体体积再求和即为总体积v。<br>凸五面体vs可分割成三个四面体v1，v2，v3；而四面体体积可利用下公式，使用Eigen库来简化矩阵运算。<br>计算出各个面片的投影体积后，将面片法线和投影面法线点乘来判定是上表面还是下表面。若s&gt;0则为上表面，该投影体积为正，若s&lt;0则为下表面，该投影体积为负。</p><pre><code class="bash">for (int i = 0; i &lt; head.faceNum; i++)    {        double x1,x2,x3,y1,y2,y3,z1,z2,z3;        x1=faces[i].p1.x;y1=faces[i].p1.y;z1=faces[i].p1.z;        x2=faces[i].p2.x;y2=faces[i].p2.y;z2=faces[i].p2.z;        x3=faces[i].p3.x;y3=faces[i].p3.y;z3=faces[i].p3.z;        Eigen::Matrix&lt;double,4,4&gt;matrix_44;        matrix_44 &lt;&lt; 1,1,1,1,x1,x2,x3,x2,y1,y2,y3,y2,z1,z2,z3,-10;        double v1=abs(matrix_44.determinant())*(1.0/6.0);        matrix_44 &lt;&lt; 1,1,1,1,x1,x1,x2,x3,y1,y1,y2,y3,z1,-10,-10,z3;        double v2=abs(matrix_44.determinant())*(1.0/6.0);        matrix_44 &lt;&lt; 1,1,1,1,x1,x2,x3,x3,y1,y2,y3,y3,-10,-10,-10,z3;        double v3=abs(matrix_44.determinant())*(1.0/6.0);        double vs=v1+v2+v3;        Eigen::Matrix&lt;double,1,3&gt;f;        f &lt;&lt; faces[i].normal.i, faces[i].normal.j, faces[i].normal.k;        Eigen::Matrix&lt;double,3,1&gt;p;        p &lt;&lt; 0,0,1;        double s = f.dot(p);        if(s&gt;0){          v=v+vs;        }else if(s&lt;0){          v=v-vs;        }    }</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学习了如何用c语言读入stl文件，和mesh的特征，表面积、体积计算方法。并复习了Eigen的使用。<br>以下是总代码：</p><pre><code class="bash">#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;#include &lt;Eigen/Core&gt;#include &lt;Eigen/Dense&gt;using namespace std;using namespace Eigen;struct Head    {    char partName[80];    //文件头    int  faceNum;    //面片个数};struct Point    //顶点{    float x;    float y;    float z;};struct Normal    //法线，k&gt;0上表面，k&lt;0下表面{    float i;    float j;    float k;};struct Face        //单位三角面，一条法线，三个顶点{    Normal normal;        Point  p1;    Point  p2;    Point  p3;    char  info[2];    //保留数据，属性信息};int main(){    Head head;    FILE* fp;    char fileName[128];    fp = fopen(&quot;1.stl&quot;, &quot;rb&quot;);    if (fp != NULL)    {        fread(head.partName, 80, 1, fp);        fread(&amp;head.faceNum, 4, 1, fp);    }    Face* faces = (Face*)malloc(head.faceNum * sizeof(Face));    for (int i = 0; i &lt; head.faceNum; i++)    {        fread(&amp;faces[i].normal, 12, 1, fp);        fread(&amp;faces[i].p1, 12, 1, fp);        fread(&amp;faces[i].p2, 12, 1, fp);        fread(&amp;faces[i].p3, 12, 1, fp);        fread(&amp;faces[i].info, 2, 1, fp);    }    fclose(fp);    double sum = 0;        //表面积    double v=0;        //体积    for (int i = 0; i &lt; head.faceNum; i++)    {        //表面积计算        double sa = sqrt((faces[i].p1.x - faces[i].p2.x) * (faces[i].p1.x - faces[i].p2.x) + (faces[i].p1.y- faces[i].p2.y) * (faces[i].p1.y - faces[i].p2.y) + (faces[i].p1.z- faces[i].p2.z) * (faces[i].p1.z - faces[i].p2.z));        double sb = sqrt((faces[i].p2.x - faces[i].p3.x) * (faces[i].p2.x - faces[i].p3.x) + (faces[i].p2.y - faces[i].p3.y) * (faces[i].p2.y - faces[i].p3.y) + (faces[i].p2.z - faces[i].p3.z) * (faces[i].p2.z - faces[i].p3.z));        double sc = sqrt((faces[i].p3.x - faces[i].p1.x) * (faces[i].p3.x - faces[i].p1.x) + (faces[i].p3.y - faces[i].p1.y) * (faces[i].p3.y - faces[i].p1.y) + (faces[i].p3.z - faces[i].p1.z) * (faces[i].p3.z - faces[i].p1.z));        double sp = (sa + sb + sc) / 2;        sum = sum + sqrt(sp * (sp - sa) * (sp - sb) * (sp - sc));        //体积计算        double x1,x2,x3,y1,y2,y3,z1,z2,z3;        x1=faces[i].p1.x;y1=faces[i].p1.y;z1=faces[i].p1.z;        x2=faces[i].p2.x;y2=faces[i].p2.y;z2=faces[i].p2.z;        x3=faces[i].p3.x;y3=faces[i].p3.y;z3=faces[i].p3.z;        Eigen::Matrix&lt;double,4,4&gt;matrix_44;        matrix_44 &lt;&lt; 1,1,1,1,x1,x2,x3,x2,y1,y2,y3,y2,z1,z2,z3,-10;        double v1=abs(matrix_44.determinant())*(1.0/6.0);        matrix_44 &lt;&lt; 1,1,1,1,x1,x1,x2,x3,y1,y1,y2,y3,z1,-10,-10,z3;        double v2=abs(matrix_44.determinant())*(1.0/6.0);        matrix_44 &lt;&lt; 1,1,1,1,x1,x2,x3,x3,y1,y2,y3,y3,-10,-10,-10,z3;        double v3=abs(matrix_44.determinant())*(1.0/6.0);        double vs=v1+v2+v3;        Eigen::Matrix&lt;double,1,3&gt;f;        f &lt;&lt; faces[i].normal.i, faces[i].normal.j, faces[i].normal.k;        Eigen::Matrix&lt;double,3,1&gt;p;        p &lt;&lt; 0,0,1;        double s = f.dot(p);        if(s&gt;0){          v=v+vs;        }else if(s&lt;0){          v=v-vs;        }    }    printf(&quot;表面积为：%lf\n&quot;, sum);    printf(&quot;体积为: %lf\n&quot;,v);    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>SLAM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>活着</title>
    <link href="/2020/08/07/%E6%B4%BB%E7%9D%80/"/>
    <url>/2020/08/07/%E6%B4%BB%E7%9D%80/</url>
    
    <content type="html"><![CDATA[<p>忍受生命赋予我们的责任，忍受现实给予我们的幸福和苦难，无聊和平庸。<br>你要做的最重要的一件事，就是活着。今天，明天，一万天，三万天，更多天，健康的，热情的，充满求知欲地活着。</p>]]></content>
    
    
    
    <tags>
      
      <tag>LIFE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《视觉SLAM》3.2 实践：Eigen</title>
    <link href="/2020/04/06/%E3%80%8A%E8%A7%86%E8%A7%89SLAM%E3%80%8B3-2-%E5%AE%9E%E8%B7%B5%EF%BC%9AEigen/"/>
    <url>/2020/04/06/%E3%80%8A%E8%A7%86%E8%A7%89SLAM%E3%80%8B3-2-%E5%AE%9E%E8%B7%B5%EF%BC%9AEigen/</url>
    
    <content type="html"><![CDATA[<h2 id="安装Eigen"><a href="#安装Eigen" class="headerlink" title="安装Eigen"></a>安装Eigen</h2><pre><code class="bash">$ sudo apt-get install libegigen3-dev</code></pre><p>安装完成后输入</p><pre><code class="bash">$ sudo updatedb$ locate eigen3</code></pre><p>查找其头文件的位置，我安装在了<code>/usr/include/eigen3/</code>中<br><img src="/img/Eigen%E5%AE%89%E8%A3%85%E4%BD%8D%E7%BD%AE.png" srcset="/img/loading.gif" alt=""></p><h2 id="开始练习"><a href="#开始练习" class="headerlink" title="开始练习"></a>开始练习</h2><p>编译时出了点小问题</p><h3 id="致-命-错-误-fatal-error"><a href="#致-命-错-误-fatal-error" class="headerlink" title="致 命 错 误 : fatal error"></a>致 命 错 误 : fatal error</h3><p><img src="/img/fatalerror.png" srcset="/img/loading.gif" alt=""><br>因为Eigen安装在<code>/usr/include/eigen3/</code>中，而默认环境变量为<code>/usr/include</code>，因此需添加路径</p><pre><code class="bash">sudo ln -s /usr/include/eigen3/Eigen /usr/include/Eigen</code></pre><p>将<code>/usr/include/eigen3/</code>映射到<code>/usr/include</code>下</p><h3 id="代码及输出"><a href="#代码及输出" class="headerlink" title="代码及输出"></a>代码及输出</h3><pre><code class="bash">#include &lt;iostream&gt;#include&lt;ctime&gt;using namespace std;#include &lt;Eigen/Core&gt;#include &lt;Eigen/Dense&gt;#define MATRIX_SIZE 50int main(){  //Eigen参数：数据类型，行，列  Eigen::Matrix&lt;float,2,3&gt;matrix_23;    //2*3的矩阵  Eigen::Vector3d v_3d;        //Eigen::Matrix&lt;double,3,1&gt;  Eigen::Matrix3d matrix_33 = Eigen::Matrix3d::Zero();        //Eigen::Matrix&lt;double,3,3&gt;,并初始化为零  Eigen::Matrix&lt;double,Eigen::Dynamic,Eigen::Dynamic&gt; matrix_dynamic;        //动态大小  Eigen::MatrixXd matrix_x;  matrix_23 &lt;&lt; 1,2,3,4,5,6;  cout &lt;&lt; matrix_23 &lt;&lt; endl;  // 1 2 3  // 4 5 6  for(int i=0; i&lt;1; i++){    for(int j=0; j&lt;2; j++){      cout &lt;&lt; matrix_23(i,j) &lt;&lt; endl;    }  }  // 1  // 2  v_3d &lt;&lt; 3,2,1;  Eigen::Matrix&lt;double, 2, 1&gt;result = matrix_23.cast&lt;double&gt;()*v_3d;  cout &lt;&lt; result &lt;&lt; endl;  // 10  // 28  //Eigen::Matrix&lt;double,2,3&gt;result_wrong_dimension = matrix_23.cast&lt;double&gt;()*v_3d;  //维度不匹配报错：/usr/include/Eigen/src/Core/Assign.h:492:3: error: ‘YOU_MIXED_MATRICES_OF_DIFFERENT_SIZES’ is not a member of ‘Eigen::internal::static_assertion&lt;false&gt;’  matrix_33 = Eigen::Matrix3d::Random();  cout &lt;&lt; matrix_33 &lt;&lt; endl &lt;&lt; endl;  // 0.680375   0.59688 -0.329554  // -0.211234  0.823295  0.536459  //  0.566198 -0.604897 -0.444451  cout &lt;&lt; matrix_33.transpose() &lt;&lt; endl;    //转置  //  0.680375 -0.211234  0.566198  //   0.59688  0.823295 -0.604897  // -0.329554  0.536459 -0.444451  cout &lt;&lt; matrix_33.sum() &lt;&lt; endl;    //各元素和  //1.61307  cout &lt;&lt; matrix_33.trace() &lt;&lt; endl;     //迹  //1.05922  cout &lt;&lt; 10*matrix_33 &lt;&lt; endl;        //数乘  //  6.80375   5.9688 -3.29554  // -2.11234  8.23295  5.36459  //  5.66198 -6.04897 -4.44451  cout &lt;&lt; matrix_33.inverse() &lt;&lt; endl;        //逆  // -0.198521   2.22739    2.8357  //   1.00605 -0.555135  -1.41603  //  -1.62213   3.59308   3.28973  cout &lt;&lt; matrix_33.determinant() &lt;&lt; endl;    //行列式  //0.208598  Eigen::SelfAdjointEigenSolver&lt;Eigen::Matrix3d&gt;eigen_solver(matrix_33.transpose()*matrix_33);  cout &lt;&lt; &quot;Eigen values = &quot; &lt;&lt; eigen_solver.eigenvalues() &lt;&lt; endl;    //特征值  //Eigen values =   //0.0242899  // 0.992154  // 1.80558  cout &lt;&lt; &quot;Eigen vectors = &quot; &lt;&lt; eigen_solver.eigenvectors() &lt;&lt; endl;    //特征向量  // Eigen vectors =   //-0.549013 -0.735943  0.396198  //  0.253452 -0.598296 -0.760134  // -0.796459  0.316906 -0.514998  Eigen::Matrix&lt;double,MATRIX_SIZE,MATRIX_SIZE&gt;matrix_NN;  matrix_NN = Eigen::MatrixXd::Random(MATRIX_SIZE,MATRIX_SIZE);  Eigen::Matrix&lt; double, MATRIX_SIZE,  1&gt; v_Nd;  v_Nd = Eigen::MatrixXd::Random( MATRIX_SIZE,1 );  clock_t time_stt = clock(); // 计时    // 直接求逆  Eigen::Matrix&lt;double,MATRIX_SIZE,1&gt; x = matrix_NN.inverse()*v_Nd;  cout &lt;&lt;&quot;time use in normal inverse is &quot; &lt;&lt; 1000* (clock() - time_stt)/(double)CLOCKS_PER_SEC &lt;&lt; &quot;ms&quot;&lt;&lt; endl;       // 通常用矩阵分解来求，例如QR分解，速度会快很多  time_stt = clock();  x = matrix_NN.colPivHouseholderQr().solve(v_Nd);   cout &lt;&lt;&quot;time use in Qr decomposition is &quot; &lt;&lt;1000*  (clock() - time_stt)/(double)CLOCKS_PER_SEC &lt;&lt;&quot;ms&quot; &lt;&lt; endl;    //time use in normal inverse is 3.494ms    //time use in Qr decomposition is 9.553ms}</code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre><code>1 2 34 5 61    2    3    4    5    6    10283277 0.680375   0.59688 -0.329554-0.211234  0.823295  0.536459 0.566198 -0.604897 -0.444451 0.680375 -0.211234  0.566198  0.59688  0.823295 -0.604897-0.329554  0.536459 -0.4444511.613071.05922 6.80375   5.9688 -3.29554-2.11234  8.23295  5.36459 5.66198 -6.04897 -4.44451-0.198521   2.22739    2.8357  1.00605 -0.555135  -1.41603 -1.62213   3.59308   3.289730.208598Eigen values = 0.02428990.9921541.80558Eigen vectors = -0.549013 -0.735943  0.396198 0.253452 -0.598296 -0.760134-0.796459  0.316906 -0.514998time use in normal inverse is 3.494mstime use in Qr decomposition is 9.553ms</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>SLAM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日落</title>
    <link href="/2020/04/01/%E6%97%A5%E8%90%BD/"/>
    <url>/2020/04/01/%E6%97%A5%E8%90%BD/</url>
    
    <content type="html"><![CDATA[<p>太阳渐渐黯淡下去<br>感到寂寞而凄凉<br>仿佛人生都被剥夺了</p>]]></content>
    
    
    
    <tags>
      
      <tag>LIFE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《视觉SLAM从入门到放弃》第二讲习题</title>
    <link href="/2020/03/16/%E3%80%8A%E8%A7%86%E8%A7%89SLAM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%E3%80%8B%E7%AC%AC%E4%BA%8C%E8%AE%B2%E4%B9%A0%E9%A2%98/"/>
    <url>/2020/03/16/%E3%80%8A%E8%A7%86%E8%A7%89SLAM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%E3%80%8B%E7%AC%AC%E4%BA%8C%E8%AE%B2%E4%B9%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p><strong>1. 阅读文献<a href="/img/基于单目视觉的同时定位与地图构建方法综述.pdf">[ 1 ]</a>和[ 14 ]，你能看懂文献的内容吗？</strong></p><ol><li>文献[ 1 ]主要专注于对基于单目视觉的 SLAM 方法的分析和讨论, 系统地介绍和分析目前 3 类(基于滤波，关键帧BA,直接跟踪)主流单目 V-SLAM 方法的优缺点, 并对它们的代表性系统进行性能分析和比较。另外, 也介绍和讨论了 V-SLAM 技术的最新研究热点和发展趋势, 并进行总结和展望。</li><li>文献[ 14 ]等找到了就看qwq</li></ol><p><strong>3. g++命令有哪些参数？再怎么填写参数可以更改生成的程序文件名？</strong></p><ol><li><a href="https://blog.csdn.net/huangyimo/article/details/78591990" target="_blank" rel="noopener">g++参数介绍</a></li><li><code>g++ 文件名 -o 执行程序名</code><br>前：<br><img src="/img/ch2_2_1.png" srcset="/img/loading.gif" alt=""><br>后：<br><img src="/img/ch2_2_2.png" srcset="/img/loading.gif" alt=""></li></ol><p><strong>5. 刻意在代码中添加一些语法错误，看看编译会生成什么样的信息。你能看懂 g++ 的错误吗？</strong><br>&emsp;我能！我百度超厉害！</p><p><strong>6. 如果忘了把库链接到可执行程序上，编译会报错吗？什么样的错？</strong><br>&emsp;那必然会<br>&emsp;<code>undefined reference</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>SLAM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>水怪</title>
    <link href="/2020/03/16/%E6%B0%B4%E6%80%AA/"/>
    <url>/2020/03/16/%E6%B0%B4%E6%80%AA/</url>
    
    <content type="html"><![CDATA[<p>我说：“我们好像在池塘的水底，从一个月亮走向另一个月亮。”<br>妖妖忽然大惊小怪地叫起来：“陈辉，你是诗人呢！”</p>]]></content>
    
    
    
    <tags>
      
      <tag>LIFE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟机+博客</title>
    <link href="/2020/03/15/%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/03/15/%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>没想到我居然还是没空<br>先占个坑，有空就写qwq</p><h2 id="hyper-Ubuntu14-4"><a href="#hyper-Ubuntu14-4" class="headerlink" title="hyper+Ubuntu14.4"></a>hyper+Ubuntu14.4</h2><div align=center><a href=https://blog.csdn.net/m0_37835884/article/details/79484242><img src="/img/我已经在线了.jpg" srcset="/img/loading.gif" width = 48%></a></div><h2 id="GitHub-hexo"><a href="#GitHub-hexo" class="headerlink" title="GitHub+hexo"></a>GitHub+hexo</h2><div align=center><a href=https://www.bilibili.com/video/av24897960?from=search&seid=10507961022384070858><img src="/img/我们是兄弟，怎么会鸽你呢.jpg" srcset="/img/loading.gif" width = 50%></a></div><h2 id="一些小问题"><a href="#一些小问题" class="headerlink" title="一些小问题"></a>一些小问题</h2><ol><li><p>关于图片，文档中提供的<code>![](/img/example.jpg)</code>无法更改大小及位置<br>于是用以下方法进行缩小与居中</p><pre><code class="bash">&lt;div align=center&gt;&lt;img src=&quot;/img/example.jpg&quot; width = &quot;200&quot; height = &quot;200&quot;&gt;&lt;/div&gt;</code></pre></li><li><p>经常碰到这种情况 : process faild<br><img src="/img/Processfailed.png" srcset="/img/loading.gif" alt=""><br>经检查还是文章头里的tags没加空格qwq<br><code>tags:SLAM</code><br><code>tags: SLAM</code></p></li><li><p>致 命 错 误 : fatal error<br><img src="/img/fatalerror.png" srcset="/img/loading.gif" alt=""><br>因为Eigen安装在<code>/usr/include/eigen3/</code>中，而默认环境变量为<code>/usr/include</code>，因此需添加路径</p><pre><code class="bash">sudo ln -s /usr/include/eigen3/Eigen /usr/include/Eigen</code></pre><p>将<code>/usr/include/eigen3/</code>映射到<code>/usr/include</code>下</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>SLAM</tag>
      
      <tag>BLOG</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
